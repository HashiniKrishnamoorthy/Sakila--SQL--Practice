-- STORED PROCEDURES
-- IT IS SAME AS FUNCTIONS , when we need to repeatly want to do a query then this function is an option
-- in SQL function are know as stored procedures 
-- it is a prepared sql code which can be saved , so that it can be reused over and over again
use sakila;
DROP PROCEDURE IF EXISTS selectallcustomers;
DELIMITER  //
-- INPUT PARAMETER
CREATE PROCEDURE selectallcustomers(IN CID varchar(25))
BEGIN
    SELECT SUM(amount) as total
	from sakila.payment
	group by customer_id 
    HAVING customer_id = CID ;
END //
DELIMITER ;

CALL selectallcustomers(15);
-- OUTPUT PARAMETER
DROP PROCEDURE sakilatotalfilms;
DELIMITER //

CREATE PROCEDURE sakilatotalfilms(IN AID INT , OUT tf INT)
BEGIN
SELECT COUNT(film_id) INTO tf
FROM sakila.film_actor
GROUP BY actor_id
HAVING actor_id = AID;
END //

DELIMITER ;

CALL sakilatotalfilms(6, @tf ); SELECT @tf;

-- Another example
-- Here whenever we are using INTO then we cannot select second column in the select statement
DELIMITER //
CREATE PROCEDURE actor_movie_information(IN AID INT)
BEGIN
SELECT CONCAT(a.first_name,' ',a.last_name )as a_name, count(f.film_id) as total_movies
FROM film_actor as  f JOIN actor  as a
on f.actor_id = a.actor_id
GROUP BY a.actor_id
HAVING COUNT(f.film_id) >= AID;
END //
DELIMITER ;
CALL actor_movie_information(10);

-- DYNAMIC STORED PROCEDURES
-- It is used to generate dynamic select statement for a table 
-- It is dynamic built a select query at run time as a STRING , it can be done by ' SET @query ='
-- And executes the query with PREPARE, EXECUTE AND DEALLOCATE PREPARE 
-- Where here the TABLE , COLUMN  and CONDITIONS everything is selected during runtime
-- IN normal SQL we can not change the columns or filters to be ruuned , but here we can do that 
DROP PROCEDURE IF EXISTS table_names;

CREATE TEMPORARY TABLE query_list (
    id INT AUTO_INCREMENT PRIMARY KEY,
    query_text VARCHAR(500)
);



DELIMITER //

CREATE PROCEDURE table_names( IN t_name VARCHAR(100))
BEGIN 
SET @query = CONCAT('SELECT * FROM',' ', t_name);

PREPARE stmt FROM @query;
EXECUTE stmt;
DEALLOCATE PREPARE stmt;
END //

DELIMITER ;

CALL table_names('film');

-- for whole database 
DROP PROCEDURE IF EXISTS Whole_database;


DELIMITER //
CREATE PROCEDURE Whole_database (IN db_name VARCHAR(50))
BEGIN 
DECLARE DONE INT DEFAULT FALSE;
DECLARE t_name varchar(50) ;
DECLARE sql_text varchar(1000);
DECLARE cur CURSOR FOR
   SELECT table_name
   from information_schema.tables
   where table_schema = db_name;

DECLARE CONTINUE HANDLER FOR NOT FOUND SET DONE = TRUE;

OPEN cur;
read_loop :loop
FETCH cur INTO t_name;
IF DONE THEN
     LEAVE read_loop;
END IF;
SET sql_text = CONCAT('SELECT * FROM `', db_name, '`.`', t_name, '`;');

INSERT INTO query_list(query_text)
VALUES (sql_text);

-- SET @query = CONCAT('SELECT * FROM',' ', db_name ,'.',t_name) ;

-- PREPARE stmt FROM @query;
-- EXECUTE stmt;
-- DEALLOCATE PREPARE stmt;
END LOOP; 
CLOSE cur; -- remember here always close not end

END //
DELIMITER ;

CALL whole_database('sakila');

-- NATURAL KEY , which naturally created , all natural keys are primary but all primary are not natural keys
drop table Employees;
CREATE TABLE Employees(
SSN varchar(50) unique PRIMARY KEY,
employee_id int , -- Here i can not auto increment it because only primary keys can be done
email varchar(100) );

INSERT INTO Employees
(SSN,employee_id ,email)
VALUES ('123 456 789',1,'hashini@gamail'),
('234 457 785',2,'reddy@220');
select * from Employees;


-- SURROGATE KAY which is automatically generated by system
drop table if exists students;
CREATE TABLE students(
student_id int auto_increment primary key,
student_name char(100),
class varchar(50));

